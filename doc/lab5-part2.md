Lab 5 Part 2: Tiger Compiler without register allocation
Description
Write a complete runnable tiger compiler, your goal is to make your compiler generate working code that runs on x86-64 platform, you can skip register allocation in this lab.

Related files for this lab are:
  • src/tiger/frame/.* Files related to function stack frame(chapter 6)

  • src/tiger/translate/.* Files related to IR tree translation(chapter 7)

  • src/tiger/canon/.* Files related to basic blocks & traces(chapter 8, this part has already been implemented)

  • src/tiger/codegen/.* Files related to assembly code generation(chapter 9)

  • src/tiger/runtime/runtime_llvm.c Tiger program runtime file(will be linked with code files generated by your compiler)

  • src/tiger/env/env.* The EnvEntry classes which help compiler store the information of variables&functions

  • src/tiger/output/output.* Files related to output assembly for frags.

To finish this lab, you will only need to finish the following modules: { x64 stack frame } { IR tree translation} { code generation } you can modify any file to finish your design

Notice: Before you start this lab, you should carefully read the chapter 6,7,8,9,12 of the textbook. And if you have any question about this lab, feel free to contact Jingkai Yang, who is the teaching assistant responsible for lab 5.

Important Notes
1. Before you start to implement code generation, carefully read the calling convention of x86-64 platform.

2. The file runtime_llvm.c is a C-language file containing several external functions useful to your Tiger program. These are generally reached by externalCall from code generated by your compiler.

3. Carefully read the chapter 12, which gives some useful interface declarations you may use in module frame.

4. You can only use one register(%rsp) as stack pointer, %rbp is not allowed to be used as stack pointer.

5. After you finish codegen, remember to check output.cc for the output of your assembly code, we have annotated some code for passing compilation.

6. You can read "main/test_codegen.cc" to figure out the order in which modules are called and the workflow of tiger compiler.

7. You must use instruction cqto before idivq, which will help you pass the subsequent lab.

8. This lab is very difficult and hard to debug, please leave yourself enough time(at least two week) to finish this lab.

Introduction to Tiger Interpreter
Since you have not finished register allocation part yet, your assembly can't link using gcc yet. We have implement a brand new way to help you do judge if your answer is right, which we call it Tiger Interpreter.
This interpreter take assembly file(.s) as input, interpre your assembly code even without RA. Your final assembly code should act should like follow:

movq t112, %rsp
addq %rcx, %rbx
leaq L1(t118), %rdi

This code doesn't make any sense, but it shows what assembly code you should generate in this lab, where t1xx represents temporary register not allocated yet. Note that you can use machine registers now, and you must use for some special insturctions(like imul/idiv, ret value).
We only support following instructions now:
movq, addq, subq, imulq, idivq, leaq, callq, cmpq, jmp, je, jne, jg, jge, jl, jle, retq, cqto, sete, setne, setg, setge, setl, setle
which is enough for you to finish this lab, if you have any better idea about instructions, you can start a issue in public repository to tell us your idea.
Besides, we have implemented a debugger inside this interpreter to help you figure out what is going wrong, details could be found here(updating). Tiger Interpreter's source code is in scripts/lab5_test, and is written in python.
Environment
You will use the same code framework that you had set up when you worked on previous lab. What you need to do now is to pull the latest update of the code framework if there are any. You may have to do some code merging jobs.

shell% git fetch upstream
shell% git checkout -b lab5-part2 upstream/lab5-part2
shell% git push -u origin
shell% git merge lab5-part1

You may have to do some code merging jobs here

After merging, you are supposed to push your update to your remote repo
shell% git add files
shell% git commit -m "[lab5-part2] merge lab5-part1"
shell% git push origin lab5-part2

If you haven't set it up before, you should follow the instructions here to set up your lab environment.

Grade Test
The lab environment contains a grading script named as grade.sh, you can use it to evaluate your code, and that's how we grade your code, too. If you pass all the tests, the script will print a successful hint, otherwise, it will output some error messages. You can execute the script with the following commands.

Remember grading your lab under docker or unix shell! Never run these commands under windows cmd.
shell% make gradelab5
shell% ...
shell% [^_^]: Pass #If you pass all the tests, you will see these messages.
shell% TOTAL SCORE: 100
If you have completed lab5-part 2 without completing the previous lab, you can also execute the script with the following commands.

Remember grading your lab under docker or unix shell! Never run these commands under windows cmd.
shell% make gradelab5-2
shell% ...
shell% [^_^]: Pass #If you pass all the tests, you will see these messages.
shell% TOTAL SCORE: 100
Both of the above will be tested in GitLab CI.

Please note that we will use the higher score of the two mentioned above as your score for lab5-part 2.

Handin
The deadline of this lab is on Tuesday 12:00 AT NOON, Dec 31, 2024, and if you miss the deadline, points will be deducted based on the number of days you are late!

After you have passed the grade test, you need first commit your modification, then push it to your remote repository on gitlab. You can use the following commands to finish this step.

shell% git add files 
shell% git commit -m "[lab5-part2] finish lab5-part2"
shell% git push origin lab5-part2 

# 指令选择算法

## Maximal Munch

+ Starting at the root of the tree, find the largest tile that fits.
+ Cover the root node - and perhaps serveral other nodes near the root leaving serveral subtrees
+ Now repeat the algorithm for each subtree

The maximum Munch algorithm generates the instructions *in reverse order*

The "Largest tile" is the one woth the most nodes.

If two tiles of equal size match at the root, then the choice between them is arbitrary.

Simply write two recursive functions, `munchStm` for statements and `munchExp` for expressions.

+ Each clause of `munchExp` will match one tile.
+ The clauses are ordered in order of tile preference (biggest tiles first)

If for each node-type in the `Tree` language, there exists a single-node tile pattern, then Maximal Munch cannot get "stuck" with no tile to match some subtree,

# 主要目标

+ 主线是进行codegen.cc中的`Codegen()`过程以生成LLVM代码。
+ 代码中出现了4处`your lab5 code here`,分别在
    + codegen.cc
    + codegen.h
    + x64frame.cc
最主要的应该是`InstrSel`，将*LLVM IR*指令翻译为`assem::Instr`从而插入`assem::InstrList`

`assem::Instr`有如下子类

+ `OperInstr`
```C++
class OperInstr : public Instr {
public:
  // 汇编字符串
  std::string assem_;
  // 目标临时变量、源临时变量
  temp::TempList *dst_, *src_;
  // 跳转目标
  Targets *jumps_;
}
```
+ `LabelInstr`
```C++
class LabelInstr : public Instr {
public:
  std::string assem_;
  temp::Label *label_;
}
```
+ `MoveInstr`

```C++
class MoveInstr : public Instr {
public:
  std::string assem_;
  temp::TempList *dst_, *src_;
}
```

+ Lecture 16: LLVM-based Instruction Selection
+ Lecture 17: LLVM-based Instruction Selection Part 2

# Lecture 16
对经典`a[i]:=x`进行转换

```llvm
%3 = getelementptr i64, i64* %2, i64 %1
%4 = add i64 %sp, 16
%x_ptr = inttoptr i64 %4 to i64*
%5 = load i64, i64* %x_ptr, align 4
store i64 %5, i64* %3, align 4
```

问题在于如何Tiling，如果直接以List进行Tiling，效果不见的好

+ For each LLVM basicblock, Convert LLVM IR list to a DAG (SelectionDAG) with return value as root node
+ Cover root node of DAG with largest tile t that fits (most nodes) 
+ Repeat for each out-edges of t.
+ Generate assembly instructions in reverse order

Maximal Munch is a little difficult in LLVM IR
Because we must convert IR list to a DAG

## `frame::Frags`
+ Store cont strings
+ Store framesize
+ Tree types of `frame::Frags`
  + `frame::StringFrag`
  + `frame::ProcFrag`
  + `frame::FrameSizeFrag`

# OperInstr

```llvm
%3= load i64, i64* %2, align 4 (as load_inst)
```

```cpp
OperInstr(std::string assem, temp::TempList *dst, temp::TempList *src,
            Targets *jumps)
```

```cpp
 assem::OperInstr("movq (`s0),`d0",
 temp::TempList(temp::TempFactory::NewTemp()),
 temp_map_->find(load_inst.getPointerOperand())->second,
nullptr)
```

```
  %2 = add i64 %1, 3
  %4 = load i64, i64* %3, align 4
  %5 = mul i32 %2, %4
```

Could be translated as follows
```
  assem				dst		src
  leaq       3(`s0),`d0		t908		t187
  movq     (`s0),`d0        	t909		t192
  imul       `s0,`d0	            t908		t908, t909
```
After register allocation, it might look like
  leaq       3(%rax),%rdi		
  movq     (%rbx),%rsi 
  imul       %rsi,%rdi

### Two address instructions

```
Two address instructions
  t1 ← t1 + t2
Can be described as
  assem				dst		src
  addq   `s0, `d0		t1		t1,t2
Where `s0 is implicitly mentioned in the assem string
```

# Function Definition

```S
P_framesize_global:
	.long 8	 
	.text
	.type	P, @function
P:
pushq 	%rbp 		
pushq 	%rbx 
subq 	$8, %rsp 		
…………	
popq 	%rbx 		
popq 	%rbp 		
addq 	$8, %rsp 
ret 
.size		P, .-P
```

## Prologue
1. Pseudo-instructions to announce the beginning of a function;
2. A label definition of the function name
3. An instruction to adjust the stack pointer.

> depend on exact knowledge of the frame size?
> Should be generated later  in a FRAME function frame::ProcEntryExit3

4. Instructions to save “escaping” arguments – including the static link –into the frame, and to move non-escaping arguments into fresh temporary registers

> CodeGen::Codegen() in /* codegen.h */
> Should also record LLVM values and temporary registers (we will discuss later)



5. Store instructions to save any **callee-saved registers**- including the return address register – used within the function
> Part of the view shift

## Epilogue
7. An instruction to move the return value (result of the function) to the register reserved for that purpose

> 7 is done at the end of function body
> Consistent with the effect of the ret instruction in LLVM


8.  Load instructions to restore the **callee-save registers**

> Part of the view shift
> assem::InstrList *frame::ProcEntryExit1(std::string_view function_name, assem::InstrList *body)


9. An instruction to reset the stack pointer (to deallocate the frame)

> depend on exact knowledge of the frame size?
> Should be generated later  in a FRAME function frame::ProcEntryExit3

10. A return instruction (Jump to the return address)
11. Pseduo-instructions, as needed, to announce the end of a function


# No Frame Pointer

In the translation phase
tiger uses a virtual frame pointer FP
each inFrame variable is referred as FP+k
replacing the FP to SP
In code generation phase
each inFrame variable is referred as SP+k+fs
fs is the size of the frame
Which can be known only after the register allocation

妈的说来说去还不是逐行翻译。

`assem::Format`在`assem::Instr::Print`中调用

而他又使用到`NthTemp`，这是在构建指令时传入的`src`和`dst`

这样才能把什么`mov ``d0, ``s0`给干了成`mov t153, t152`

## `GetElementPtr`指令的翻译

指针与两个索引

+ `Pointer Base`
+ `Index`
  + 第一个往往为0
  + 第二个表示数组索引或者结构体成员索引
在我们的实现中，所有字段都占用8个字节，即使储存i32只使用了其中4个字节？
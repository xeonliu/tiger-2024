Lab 5 Part 1: Escape Analysis and Translation
Description
In this lab, you're going to do the escape analysis and translation of tiger compiler, you're supposed to ensure your escape analysis right and your translation should be a valid LLVM program and produce the expected output.

Related files for this lab are:

src/tiger/frame/.* Files related to function stack frame(chapter 6)

src/tiger/translate/.* Files related to llvm IR translation(chapter 7 & slides)

src/tiger/runtime/runtime_llvm.c Tiger program runtime file(will be linked with code files generated by your compiler)

src/tiger/env/env.* The EnvEntry classes which help compiler store the information of variables&functions

src/tiger/escape/escape.* Files related to escape analysis(chapter 6)

To finish this lab, you will only need to finish the following modules: { x64 stack frame } { llvm IR translation } { escape analysis } you can modify any file to finish your design.

Notice: Before you start this lab, you should carefully read the chapter 6,7 of the textbook and course slides. And if you have any question about this lab, feel free to contact Hongtao Lyu, who is the teaching assistant responsible for lab5 part1.

Important Notes
Before you start to implement LLVM translation, carefully check the slides of this course.

In this experiment, reference output translated to LLVM is provided at testdata/lab5or6/llvm-refs/.*. It is not required for your compiler to produce exactly the same results, but when you encounter difficulties, we hope that the reference output can offer suggestions for your debugging.

In the grade script, the debug-level compilation option is enabled by default for everyone. Those who compile manually can also use mkdir build -p; cd build; cmake -DCMAKE_BUILD_TYPE=Debug .. ; make test_translate_llvm to manually build the debug-level executable. The LLVM IR construction system can easily encounter SIGSEGV due to improper usage, so it is recommended to make use of debugging tools such as gdb.

The file runtime_llvm.c is a C-language file containing several external functions useful to your Tiger program.

This lab is very difficult, please leave yourself enough time to finish this lab.

Environment
You will use the same code framework that you had set up when you worked on lab4 and use the code you written in previous labs. What you need to do now is to fetch the latest update and you may have to do some code merging jobs. If you have any difficulties in merging codes, you can ask TAs in our Wechat group.

shell% git checkout -b lab5-part1 upstream/lab5-part1
shell% git push -u origin
shell% git merge lab4
You may have to do some code merging jobs here

After merging, you are supposed to push your update to your remote repo

shell% git add files
shell% git commit -m "[lab5-1] merge lab4"
shell% git push origin lab5-part1
Note that in this lab you must carefully merge and make sure you get full score for pervious lab, unless you may not get full score for this lab.
If you haven't set it up before, you should follow the instructions here to set up your lab environment.

Grade Test
The lab environment contains a grading script named as grade.sh, you can use it to evaluate your code, and that's how we grade your code, too. If you pass all the tests, the script will print a successful hint, otherwise, it will output some error messages. You can execute the script with the following commands.

Remember grading your lab under docker or unix shell! Never run these commands under windows cmd.

shell% make gradelab5-1
shell% ...
shell% [^_^]: Pass #If you pass all the tests, you will see these messages.
shell% TOTAL SCORE: 100
Handin
The deadline of this lab is on Tuesday 12:00 AT NOON, December 10, 2024, and if you miss the deadline, points will be deducted based on the number of days you are late!

`frame/frame.h`

+ `RegManager`：表示可用的寄存器
+ `Access`(TODO)：表示局部变量？
+ `Frame`
+ `Frag`
    + `StringFrag`
    + `FrameSizeFrag`
    + `ProcFrag` 
+ `Frags`

```
class RegManager {
public:
    temp::Map *temp_map_;
    std::vector<temp::Temp *> regs_;
}
```

Reg就是Temp???

`frame/temp.h`

+ `LabelFactory`
+ `TempFactory`
+ `Map`
+ `TempList`

`frame/x64frame.h`

+ `X64RegManager : RegManager`

`frame/x64frame.cc`

+ `InFrameAccess : public Access`
    + `int offset`
    + `frame::Frame *parent_frame`

表示函数参数或者局部变量在栈帧中的位置和访问方式？

+ `X64Frame : Frame`
    + ` X64Frame(temp::Label *name, std::list<frame::Access *> *formals`

# Frame类

`frame::Frame *NewFrame(temp::Label *name, std::list<bool> formals)`
创建一个新的Frame
在Translate声明函数时需要调用。

## 构造函数

`Frame(int outgo_size, int offset, temp::Label *name,
        std::list<frame::Access *> *formals)`

```C++
// 是一个整数，表示函数调用时需要为传递给其他函数的参数预留的栈空间的大小
  int outgo_size_;
  // offset_是一个整数，表示当前Frame中局部变量和参数的偏移量，是一个负数。
  int offset_;
  temp::Label *name_;
  std::list<frame::Access *> *formals_;
  llvm::GlobalVariable *framesize_global;
  llvm::Value *sp;
```

这静态变量挺有意思。
```
class TempFactory {
public:
  // 获取新的Temp对象，静态的Factory其temp_id_自增
  static Temp *NewTemp();

private:
  int temp_id_ = 100;
  static TempFactory temp_factory;
};
```

# Translate

`translate.h`

`tr::Access`

```C++
Access(Level *level, frame::Access *access)
      : level_(level), access_(access) {}
```

`tr::Level`

```
Level(frame::Frame *frame, Level *parent) : frame_(frame), parent_(parent) {}
```

`tr::ProgTr`

把`absyn::AbsynTree`变成一个IR Tree.

```C++
private:
  std::unique_ptr<absyn::AbsynTree> absyn_tree_;
  std::unique_ptr<err::ErrorMsg> errormsg_;
  std::unique_ptr<Level> main_level_;
  std::unique_ptr<env::TEnv> tenv_;
  std::unique_ptr<env::VEnv> venv_;
```

## Translate Simple Variables

怎样完成一个获取地址的操作

+ `tr::Access`
  + Can be obtained by querying venv????
  + `SimpleVar::Translate() eventually calls 
     	llvm::Value *frame::Access::ToLLVMVal(
		llvm::Value *frame_addr_ptr)`


```llvm
%x_offset = add i64 %func_framesize, -k
%x_addr = add i64 %func_sp, %x_offset 
%x_ptr = inttoptr i64 %x_addr to i32*
```

直接生成最后一行。前两行隐含在下述代码之中。

```C++
llvm::Value *val = ir_builder->CreateIntToPtr(
          var_faccess->ToLLVMVal(level->get_sp()),  // 使用Var（关联？）的Access类获取其地址
          llvm::PointerType::get(var_entry->ty_->GetLLVMType(), 0), // 类型
          "x_ptr");
return new tr::ValAndTy(val, var_entry->ty_->ActualTy());
```

```C++
llvm::Value *val = level->get_sp();
// 遍历静态链，指导找到目标变量所在的层级
while (level != var_level) {
  // The first accessible frame-offset_ values is the static link
  auto sl_formal = level->Formals()->begin();
  llvm::Value *static_link_addr = (*sl_formal)->access_->ToLLVMVal(val);
  llvm::Value *static_link_ptr = ir_builder->CreateIntToPtr(
      static_link_addr,
      llvm::Type::getInt64PtrTy(ir_builder->getContext()));
  val = ir_builder->CreateLoad(ir_builder->getInt64Ty(), static_link_ptr);
  level = level->parent_;
}
val = var_faccess->ToLLVMVal(val);
```

# 作为lvalue的var

所有的Var都是lvalue！

> In Tiger, all Var are seen as pointers *by default*

+ 需要使用Var的值时（作为rvalue使用时），注意进行转换！
+ 当赋值发生时，则使用指针

## 将Var作为右值使用

使用Load指令进行转换（Lecture 14 P38）

Insert `load` when necessary (when type inconsistency)



## 将Var作为左值使用

赋值被翻译为区间内存拷贝

> Size of l-value should be considered, and assign should be translated into a range memory copy

# LLVM String
由长度和指针一起构成。
```llvm
%string = type { i32, i8* }
@0 = private unnamed_addr constant [21 x i8] c"hey! Bigger than 3!\0A\00", align 1
@str = constant %string { i32 20, i8* getelementptr inbounds ([21 x i8], [21 x i8]* @0, i32 0, i32 0) }
```

// FunctionType
    std::vector<llvm::Type *> llvm_param_types;
    std::transform(formal_ty_list.begin(), formal_ty_list.end(), std::back_inserter(llvm_param_types),
             [](type::Ty *ty) { return ty->GetLLVMType(); });

# 函数定义

翻译过程中，函数的栈帧大小在何时得以确定？

在函数Body翻译完成的时候。
此时在栈上分配的的局部变量和Call导致的outgo_size_都已经确定？

当前函数栈帧中的Static Link指向的是父函数的st

Return Address 和 实参传递 由 LLVM 处理，无需人工干预。

实参传递给子函数后，由子函数通过Store指令将接收到的参数储存到父函数栈帧中的outgo_size_区域内？

栈指针如何传递？

```
/**
  foo():
    dec X, Y, Z
    bar(X, Y+Z)
  
  ---------------------- foo's stack top
    | Z           |
    | Y           |       local vars in foo
    | X           |
    -------------------- (-offset)
    | arg2        |
    | arg1        |       args for bar. Belong to Foo's Allocation Actual Frame Size
    | Static Link |
    -------------------- (outgo_size_)
    | Return Address |
    -------------------- bar's stack top
    | k |
    | j |
    | i |

 */
```



## 生成的汇编
第一个参数是Parent Stack Pointer?
读取后一直作为临时值进行使用
第二个参数是 Static Link 地址
需要存入栈中
后续是函数的实参
也都需要存入栈中

Store %sl, %2 %3 … to their InFrameAccess address(init)

## IR生成
通过函数定义计算实际参数大小
进而计算出frame_size
储存在全局变量中

翻译Access时将反复从这个全局变量读出？

# 函数调用

```llvm
%3 = call i32 @g(i64 %tigermain_sp, i64 %tigermain_sp, i32 9, i32 4)
```

# Static Link

Static Link在调用时传递给子函数
其值应该为函数定义时对应父函数的`Stack Pointer`

为了找到这个父函数的`sp`，也需要使用静态链

以Python为例

```python
def f():
  def g():
    # ...
  def h():
    # Call g
    # Param 1: Caller's Stack Pointer
    # Param 2: Static Link (The Stack Pointer of the function **in which it was defined**)
    g(h_sp, f_sp)
```

静态链提供了两种功能：
+ 在嵌套函数中使得内部函数可以在运行时访问外部函数的局部变量
+ 在运行时，嵌套函数的调用顺序和次数可能无法在编译时确定，因此使用动态机制。


定义时的层次是使用`Level`和`Frame`追踪的

关于传参。是Callee往Callee的Runtime Frame Pointer (Stack Top)上边存！在函数定义时要注意翻译这些指令。

运行时的行为由翻译阶段LLVM指令去实现。

注意避免out of scope 的 sp。
这就是为什么不能直接 level->sp 而要使用Static Link逐层获取的缘故

```C
tig.ll:96:17: error: use of undefined value '%tiger_main_sp'
  %18 = add i64 %tiger_main_sp, %17
                ^
1 error generated.
```

```cpp
auto st = level->get_sp();

// 2. The function in which it is defined is not the caller
// use static link to find the correct sp
// NOTE: The highest Static Link is the sp of tiger_main
// Find out the Frame in which the callee is defined
for (auto curr_level = level; curr_level != fun_entry->level_->parent_;
      curr_level = curr_level->parent_) {
  auto st_access = curr_level->frame_->Formals()->front();

  // Address of the static link
  llvm::Value *st_addr = st_access->ToLLVMVal(curr_level->get_fp(st));
  llvm::Value *st_ptr = ir_builder->CreateIntToPtr(
      st_addr, llvm::PointerType::get(ir_builder->getInt64Ty(), 0));

  // Load the static link
  st = ir_builder->CreateLoad(ir_builder->getInt64Ty(), st_ptr);
}

args.emplace_back(st);
```

任何变量都占用8字节，都存的是指针。
真实的数据通过外部函数`alloc`

```C
// Alloc size bytes and interpret as int[]
int *alloc_record(int size) {
  int i;
  int *p, *a;
  p = a = (int *)malloc(size);
  for (i = 0; i < size; i += sizeof(int)) *p++ = 0;
  return a;
}
```